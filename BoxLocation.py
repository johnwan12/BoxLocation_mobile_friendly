# BoxLocation.py ‚Äî Professional UI + Simple Workflow + Sticky Header + Tabs (NO DEBUG)
# ============================================================
# ‚úÖ Storage = LN Tank uses tab LN3 ONLY
# ‚úÖ Subset LN3 by TankID == LN1/LN2/LN3 and show LN Inventory Table
# ‚úÖ FIND tab:
#    - Storage=LN Tank: show LN Inventory Table (selected tank)
#    - Storage=Freezer: show Freezer Search by BoxLabel_group (selected freezer)
# ‚úÖ FIND focus (your new request):
#    - Storage=Freezer AND Freezer in {Tom, Jerry}: Freezer Search is shown FIRST, highlighted, and auto-scrolled (best-effort)
# ‚úÖ Box Location area:
#    - Storage=Freezer: ALWAYS visible (not an expander) with title "üì¶ {FREEZER}: Box Location"
#    - Storage=LN Tank: expander collapsed by default
# ‚úÖ Workflow tabs: Find / Add / Use / History / Session Report
# ‚úÖ Compact Context Bar always visible
# ‚úÖ Sticky header + sticky tabs (best-effort CSS)
# ‚úÖ QR is generated by QuickChart (no qrcode dependency)
# ‚úÖ fetch_bytes() disables proxies to reduce SSL WRONG_VERSION_NUMBER issues
# ‚úÖ After saving Freezer record:
#    - INSERT a NEW row into boxNumber tab:
#      * StudyID   = "Prefix + Tube suffix"
#      * BoxNumber = BoxID used in Freezer_Inventory ‚úÖ (so boxNumber can be used for max)
# ‚úÖ When Freezer TubeAmount becomes 0:
#    - Delete the Freezer_Inventory row
#    - Delete matching boxNumber row(s) where StudyID == "Prefix + Tube suffix"
# ‚úÖ Download CSV file_name includes TubeNumber, Time_stamp, and ShippingTo
# ‚úÖ Mitigate Google Sheets 429 read quota using caching on reads (TTL)
# ‚úÖ Max BoxID rules (your request):
#    - Freezer add: max BoxID comes from boxNumber!BoxNumber
#    - LN add:      max BoxID comes from LN3!BoxID
# ============================================================

import re
import time
import random
import urllib.parse
import urllib.request
from datetime import datetime
from typing import Tuple, List

import pandas as pd
import pytz
import streamlit as st
import streamlit.components.v1 as components
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

# -------------------- Page --------------------
st.set_page_config(
    page_title="Sample Inventory",
    layout="centered",
    initial_sidebar_state="collapsed",
)

# -------------------- Sticky header + clean UI CSS --------------------
st.markdown(
    """
<style>
/* --- base spacing --- */
.block-container { padding-top: 0.75rem; }

/* --- sticky header (best-effort) --- */
[data-testid="stAppViewContainer"] > .main > div:first-child {
  position: sticky;
  top: 0;
  z-index: 999;
  background: rgba(255,255,255,0.92);
  backdrop-filter: blur(8px);
  border-bottom: 1px solid rgba(0,0,0,0.08);
}

/* --- sticky tabs (best-effort) --- */
.stTabs [data-baseweb="tab-list"] {
  position: sticky;
  top: 3.7rem; /* tweak if header height differs */
  z-index: 998;
  background: rgba(255,255,255,0.92);
  backdrop-filter: blur(8px);
  padding: 0.25rem 0;
  border-bottom: 1px solid rgba(0,0,0,0.06);
}

/* Compact header typography */
h1 { margin: 0.1rem 0 0.25rem 0; }
h2, h3 { margin-top: 0.6rem; }

/* Buttons full-width on mobile */
@media (max-width: 640px) {
  .block-container { padding-left: 0.8rem; padding-right: 0.8rem; padding-top: 0.6rem; }
  h1 { font-size: 1.35rem; }
  h2 { font-size: 1.1rem; }
  h3 { font-size: 1.02rem; }
  .stButton>button, .stDownloadButton>button { width: 100%; }
  .stTextInput>div>div>input,
  .stNumberInput>div>div>input,
  .stSelectbox>div>div,
  .stTextArea textarea { font-size: 1rem; }
}

/* Dataframe padding */
div[data-testid="stDataFrame"] { padding: 0.25rem 0; }

/* Tabs look a little more ‚Äúapp-like‚Äù */
.stTabs [data-baseweb="tab-list"] { gap: 0.25rem; }
.stTabs [data-baseweb="tab"] {
  padding: 8px 12px;
  border-radius: 10px;
}
.stTabs [aria-selected="true"] {
  border-bottom: none !important;
  background: rgba(0,0,0,0.05);
}

/* Cards */
.boxloc-card {
  border: 1px solid rgba(0,0,0,0.08);
  background: rgba(0,0,0,0.02);
  border-radius: 12px;
  padding: 12px 12px 6px 12px;
  margin: 6px 0 10px 0;
}
.focus-card {
  border: 2px solid rgba(0,0,0,0.16);
  background: rgba(0,0,0,0.03);
  border-radius: 14px;
  padding: 10px 12px 8px 12px;
  margin: 6px 0 12px 0;
}
</style>
""",
    unsafe_allow_html=True,
)

# -------------------- Session State --------------------
if "last_qr_link" not in st.session_state:
    st.session_state.last_qr_link = ""
if "last_qr_uid" not in st.session_state:
    st.session_state.last_qr_uid = ""
if "usage_final_rows" not in st.session_state:
    st.session_state.usage_final_rows = []
if "mobile_mode" not in st.session_state:
    st.session_state.mobile_mode = True

# -------------------- Constants --------------------
DISPLAY_TABS = ["Cocaine", "Cannabis", "HIV-neg-nondrug", "HIV+nondrug"]
TAB_MAP = {
    "Cocaine": "cocaine",
    "Cannabis": "cannabis",
    "HIV-neg-nondrug": "HIV-neg-nondrug",
    "HIV+nondrug": "HIV+nondrug",
}

BOX_TAB = "boxNumber"
LN_TAB = "LN3"  # Always LN in LN3 tab
FREEZER_TAB = "Freezer_Inventory"
USE_LOG_TAB = "Use_log"

# Shared columns
BOX_LABEL_COL = "BoxLabel_group"
BOXID_COL = "BoxID"
AMT_COL = "TubeAmount"
MEMO_COL = "Memo"

# LN columns
TANK_COL = "TankID"
RACK_COL = "RackNumber"
TUBE_COL = "TubeNumber"
BOXUID_COL = "BoxUID"
QR_COL = "QRCodeLink"

# Freezer columns
FREEZER_COL = "FreezerID"
PREFIX_COL = "Prefix"
SUFFIX_COL = "Tube suffix"
DATE_COLLECTED_COL = "Date Collected"
SAMPLES_RECEIVED_COL = "Samples Received"
MISSING_COL = "Missing"
URINE_RESULTS_COL = "Urine Results"
COLLECTED_BY_COL = "Collected By"

HIV_CODE = {"HIV+": "HP", "HIV-": "HN"}
DRUG_CODE = {"Cocaine": "COC", "Cannabis": "CAN", "Poly": "POL", "NON-DRUG": "NON-DRUG"}

QR_PX = 118
SPREADSHEET_ID = st.secrets["connections"]["gsheets"]["spreadsheet"]
NY_TZ = pytz.timezone("America/New_York")

# -------------------- Google Sheets service --------------------
@st.cache_resource(show_spinner=False)
def sheets_service():
    scopes = ["https://www.googleapis.com/auth/spreadsheets"]
    creds = Credentials.from_service_account_info(dict(st.secrets["google_service_account"]), scopes=scopes)
    return build("sheets", "v4", credentials=creds, cache_discovery=False)

# -------------------- Helpers --------------------
def safe_strip(x) -> str:
    return "" if x is None else str(x).strip()

def normalize_spaces(s: str) -> str:
    return re.sub(r"\s+", " ", safe_strip(s))

def to_int_amount(x, default=0) -> int:
    try:
        s = safe_strip(x)
        if s == "":
            return default
        return int(float(s))
    except Exception:
        return default

def col_to_a1(col_idx_0based: int) -> str:
    n = col_idx_0based + 1
    s = ""
    while n:
        n, r = divmod(n - 1, 26)
        s = chr(65 + r) + s
    return s

def now_timestamp_str() -> str:
    now = datetime.now(NY_TZ)
    time_str = now.strftime("%I:%M:%S").lstrip("0") or now.strftime("%I:%M:%S")
    date_str = now.strftime("%m/%d/%Y")
    return f"{time_str} {date_str}"

def today_str_ny() -> str:
    d = datetime.now(NY_TZ).date()
    return d.strftime("%m/%d/%Y")

def split_tube_number(t: str) -> Tuple[str, str]:
    t = normalize_spaces(t)
    if not t:
        return "", ""
    parts = t.split(" ", 1)
    if len(parts) == 1:
        return parts[0], ""
    return parts[0], parts[1]

def qr_link_for_boxuid(box_uid: str, px: int = QR_PX) -> str:
    text = urllib.parse.quote(box_uid, safe="")
    return f"https://quickchart.io/qr?text={text}&size={px}&ecLevel=Q&margin=1"

def fetch_bytes(url: str, timeout: int = 12) -> bytes:
    # Disable proxies to reduce SSL WRONG_VERSION_NUMBER issues
    req = urllib.request.Request(url, headers={"User-Agent": "Mozilla/5.0"})
    opener = urllib.request.build_opener(urllib.request.ProxyHandler({}))
    with opener.open(req, timeout=timeout) as resp:
        return resp.read()

def err_detail(e: Exception) -> str:
    # kept for internal logging; we don't display raw error in UI (NO DEBUG)
    try:
        if isinstance(e, HttpError):
            content = getattr(e, "content", b"")
            if content:
                return content.decode("utf-8", errors="ignore")
    except Exception:
        pass
    return str(e)

def read_tab(tab_name: str) -> pd.DataFrame:
    svc = sheets_service()
    resp = svc.spreadsheets().values().get(
        spreadsheetId=SPREADSHEET_ID,
        range=f"{tab_name}!A1:ZZ",
        valueRenderOption="UNFORMATTED_VALUE",
    ).execute()

    values = resp.get("values", [])
    if not values:
        return pd.DataFrame()

    header_raw = [safe_strip(h) for h in values[0]]
    last = max([i for i, h in enumerate(header_raw) if h != ""], default=-1)
    header = header_raw[: last + 1] if last >= 0 else []
    rows = values[1:]
    n = len(header)

    if n == 0:
        return pd.DataFrame()

    fixed = []
    for r in rows:
        r = list(r)
        if len(r) < n:
            r += [""] * (n - len(r))
        elif len(r) > n:
            r = r[:n]
        fixed.append(r)

    return pd.DataFrame(fixed, columns=header)

def read_tab_with_backoff(tab_name: str, tries: int = 5) -> pd.DataFrame:
    for i in range(tries):
        try:
            return read_tab(tab_name)
        except HttpError as e:
            msg = err_detail(e)
            if "429" in msg or "RESOURCE_EXHAUSTED" in msg or "RATE_LIMIT_EXCEEDED" in msg:
                time.sleep((2 ** i) + random.random())
                continue
            raise
    raise RuntimeError(f"Read quota exceeded too long when reading {tab_name}. Try again in ~1 minute.")

@st.cache_data(ttl=30, show_spinner=False)
def read_tab_cached(tab_name: str) -> pd.DataFrame:
    return read_tab_with_backoff(tab_name)

@st.cache_data(ttl=300, show_spinner=False)
def get_sheet_titles(spreadsheet_id: str) -> list:
    svc = sheets_service()
    meta = svc.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
    return [s["properties"]["title"] for s in meta.get("sheets", [])]

@st.cache_data(show_spinner=False)
def get_sheet_id_map(spreadsheet_id: str) -> dict:
    svc = sheets_service()
    meta = svc.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
    return {s["properties"]["title"]: int(s["properties"]["sheetId"]) for s in meta.get("sheets", [])}

def get_sheet_id(service, sheet_title: str) -> int:
    m = get_sheet_id_map(SPREADSHEET_ID)
    if sheet_title in m:
        return m[sheet_title]
    raise ValueError(f"Could not find sheetId for tab: {sheet_title}")

def get_header(service, tab: str) -> list:
    resp = service.spreadsheets().values().get(
        spreadsheetId=SPREADSHEET_ID,
        range=f"{tab}!A1:ZZ1",
        valueRenderOption="UNFORMATTED_VALUE",
    ).execute()
    row1 = (resp.get("values", [[]]) or [[]])[0]
    row1 = [safe_strip(x) for x in row1]
    last = max([i for i, h in enumerate(row1) if h != ""], default=-1)
    return row1[: last + 1] if last >= 0 else []

def set_header_if_blank(service, tab: str, header: list):
    resp = service.spreadsheets().values().get(
        spreadsheetId=SPREADSHEET_ID,
        range=f"{tab}!A1:ZZ1",
        valueRenderOption="UNFORMATTED_VALUE",
    ).execute()
    row1 = (resp.get("values", [[]]) or [[]])[0]
    row1 = [safe_strip(x) for x in row1]
    if (not row1) or all(x == "" for x in row1):
        service.spreadsheets().values().update(
            spreadsheetId=SPREADSHEET_ID,
            range=f"{tab}!A1",
            valueInputOption="RAW",
            body={"values": [header]},
        ).execute()

def append_row_by_header(service, tab: str, data: dict):
    header = get_header(service, tab)
    if not header:
        raise ValueError(f"{tab} header row is empty.")
    aligned = [data.get(col, "") for col in header]
    service.spreadsheets().values().append(
        spreadsheetId=SPREADSHEET_ID,
        range=f"{tab}!A:ZZ",
        valueInputOption="RAW",
        insertDataOption="INSERT_ROWS",
        body={"values": [aligned]},
    ).execute()

def cleanup_zero_amount_rows(service, tab_name: str, df: pd.DataFrame, amount_col: str = AMT_COL) -> List[int]:
    if df is None or df.empty or amount_col not in df.columns:
        return []
    amounts = pd.to_numeric(df[amount_col], errors="coerce").fillna(0).astype(int)
    zero_idxs = [int(i) for i in df.index[amounts == 0].tolist()]
    if not zero_idxs:
        return []

    sheet_id = get_sheet_id(service, tab_name)
    zero_idxs.sort(reverse=True)
    requests = [{
        "deleteDimension": {
            "range": {
                "sheetId": sheet_id,
                "dimension": "ROWS",
                "startIndex": idx0 + 1,
                "endIndex": idx0 + 2,
            }
        }
    } for idx0 in zero_idxs]

    for i in range(0, len(requests), 400):
        service.spreadsheets().batchUpdate(
            spreadsheetId=SPREADSHEET_ID,
            body={"requests": requests[i:i + 400]},
        ).execute()
    return zero_idxs

def update_amount_by_index(service, tab_name: str, idx0: int, amount_col: str, new_amount: int):
    header = get_header(service, tab_name)
    if amount_col not in header:
        raise ValueError(f"{tab_name} missing '{amount_col}' column in header.")
    col_idx = header.index(amount_col)
    a1_col = col_to_a1(col_idx)
    sheet_row = idx0 + 2
    service.spreadsheets().values().update(
        spreadsheetId=SPREADSHEET_ID,
        range=f"{tab_name}!{a1_col}{sheet_row}",
        valueInputOption="RAW",
        body={"values": [[int(new_amount)]]},
    ).execute()

def delete_row_by_index(service, tab_name: str, idx0: int):
    sheet_id = get_sheet_id(service, tab_name)
    start = idx0 + 1
    service.spreadsheets().batchUpdate(
        spreadsheetId=SPREADSHEET_ID,
        body={"requests": [{
            "deleteDimension": {
                "range": {
                    "sheetId": sheet_id,
                    "dimension": "ROWS",
                    "startIndex": start,
                    "endIndex": start + 1,
                }
            }
        }]},
    ).execute()

def compute_next_boxuid(ln_view_df: pd.DataFrame, tank_id: str, rack: int, hp_hn: str, drug_code: str) -> str:
    tank_id = safe_strip(tank_id).upper()
    prefix = f"{tank_id}-R{int(rack):02d}-{hp_hn}-{drug_code}-"
    max_n = 0
    if ln_view_df is not None and (not ln_view_df.empty) and (BOXUID_COL in ln_view_df.columns):
        for v in ln_view_df[BOXUID_COL].dropna().astype(str):
            s = v.strip()
            if s.startswith(prefix) and re.search(r"-(\d{2})$", s):
                try:
                    n = int(s.split("-")[-1])
                    max_n = max(max_n, n)
                except ValueError:
                    pass
    nxt = max_n + 1
    if nxt > 99:
        raise ValueError(f"BoxUID sequence exceeded 99 for {prefix}**")
    return f"{prefix}{nxt:02d}"

def ensure_ln_header(service):
    set_header_if_blank(service, LN_TAB, [
        "TankID", "RackNumber", "BoxLabel_group", "BoxUID",
        "TubeNumber", "TubeAmount", "Memo", "BoxID", "QRCodeLink",
    ])

def ensure_freezer_header(service):
    set_header_if_blank(service, FREEZER_TAB, [
        "FreezerID", "BoxID", "Prefix", "Tube suffix", "TubeAmount",
        "Date Collected", "BoxLabel_group", "Samples Received",
        "Missing", "Urine Results", "Collected By", "Memo",
    ])

def ensure_use_log_header(service):
    set_header_if_blank(service, USE_LOG_TAB, [
        "StorageType", "TankID", "RackNumber", "FreezerID",
        "BoxLabel_group", "BoxID", "TubeNumber", "Prefix", "Tube suffix",
        "Use", "User", "Time_stamp", "ShippingTo", "Memo",
    ])

def ensure_boxnumber_header(service):
    set_header_if_blank(service, BOX_TAB, ["StudyID", "BoxNumber"])

def insert_boxnumber_row(service, study_id_value: str, box_number_value: str):
    ensure_boxnumber_header(service)
    append_row_by_header(
        service,
        BOX_TAB,
        {"StudyID": safe_strip(study_id_value), "BoxNumber": safe_strip(box_number_value)},
    )

def delete_boxnumber_rows_by_studyid(service, study_id_value: str) -> int:
    ensure_boxnumber_header(service)
    df = read_tab_cached(BOX_TAB)
    if df is None or df.empty or "StudyID" not in df.columns:
        return 0

    target = normalize_spaces(study_id_value)
    df2 = df.copy()
    df2["StudyID"] = df2["StudyID"].astype(str).map(normalize_spaces)

    hit_idxs = [int(i) for i in df2.index[df2["StudyID"] == target].tolist()]
    if not hit_idxs:
        return 0

    sheet_id = get_sheet_id(service, BOX_TAB)
    hit_idxs.sort(reverse=True)

    requests = []
    for idx0 in hit_idxs:
        requests.append({
            "deleteDimension": {
                "range": {
                    "sheetId": sheet_id,
                    "dimension": "ROWS",
                    "startIndex": idx0 + 1,
                    "endIndex": idx0 + 2,
                }
            }
        })

    for i in range(0, len(requests), 400):
        service.spreadsheets().batchUpdate(
            spreadsheetId=SPREADSHEET_ID,
            body={"requests": requests[i:i + 400]},
        ).execute()

    return len(hit_idxs)

def freezer_studyid_from_row(df: pd.DataFrame, idx0: int) -> str:
    try:
        p = safe_strip(df.loc[idx0, PREFIX_COL]).upper()
        s = safe_strip(df.loc[idx0, SUFFIX_COL])
        return normalize_spaces(f"{p} {s}".strip())
    except Exception:
        return ""

# -------------------- Max BoxID rules --------------------
def get_current_max_boxid_from_boxnumber() -> int:
    try:
        df = read_tab_cached(BOX_TAB)
        if df is None or df.empty:
            return 0
        if "BoxNumber" not in df.columns:
            return 0
        s = pd.to_numeric(df["BoxNumber"], errors="coerce").dropna()
        return int(s.max()) if not s.empty else 0
    except Exception:
        return 0

def get_current_max_boxid_from_ln3() -> int:
    try:
        df = read_tab_cached(LN_TAB)
        if df is None or df.empty:
            return 0
        if BOXID_COL not in df.columns:
            return 0
        s = pd.to_numeric(df[BOXID_COL], errors="coerce").dropna()
        return int(s.max()) if not s.empty else 0
    except Exception:
        return 0

def build_use_log_row(storage_type, tank_id, rack_number, freezer_id, box_label_group, boxid,
                      prefix, suffix, use_amt, user_initials, shipping_to, memo_in) -> dict:
    tube_number_combined = normalize_spaces(f"{safe_strip(prefix).upper()} {safe_strip(suffix)}".strip())
    return {
        "StorageType": safe_strip(storage_type),
        "TankID": safe_strip(tank_id).upper(),
        "RackNumber": safe_strip(rack_number),
        "FreezerID": safe_strip(freezer_id).upper(),
        "BoxLabel_group": safe_strip(box_label_group),
        "BoxID": safe_strip(boxid),
        "TubeNumber": tube_number_combined,
        "Prefix": safe_strip(prefix).upper(),
        "Tube suffix": safe_strip(suffix),
        "Use": int(use_amt),
        "User": safe_strip(user_initials).upper(),
        "Time_stamp": now_timestamp_str(),
        "ShippingTo": safe_strip(shipping_to),
        "Memo": safe_strip(memo_in),
    }

def build_final_report_row(storage_type, storage_id, box_label_group, boxid, prefix, suffix,
                           use_amt, user_initials, time_stamp, shipping_to, memo) -> dict:
    return {
        "StorageType": safe_strip(storage_type),
        "StorageID": safe_strip(storage_id).upper(),
        "BoxLabel_group": safe_strip(box_label_group),
        "BoxID": safe_strip(boxid),
        "Prefix": safe_strip(prefix).upper(),
        "Tube suffix": safe_strip(suffix),
        "Use": int(use_amt),
        "User": safe_strip(user_initials).upper(),
        "Time_stamp": safe_strip(time_stamp),
        "ShippingTo": safe_strip(shipping_to),
        "Memo": safe_strip(memo),
    }

def find_ln_row_index(ln_all_df: pd.DataFrame, tank_id: str, box_label_group: str, boxid: str, tube_number: str):
    if ln_all_df is None or ln_all_df.empty:
        return None, None
    needed = {TANK_COL, BOX_LABEL_COL, BOXID_COL, TUBE_COL, AMT_COL}
    if not needed.issubset(set(ln_all_df.columns)):
        return None, None

    df = ln_all_df.copy()
    df[TANK_COL] = df[TANK_COL].astype(str).map(lambda x: safe_strip(x).upper())
    df[BOX_LABEL_COL] = df[BOX_LABEL_COL].astype(str).map(safe_strip)
    df[BOXID_COL] = df[BOXID_COL].astype(str).map(safe_strip)
    df[TUBE_COL] = df[TUBE_COL].astype(str).map(normalize_spaces)

    tube_number_norm = normalize_spaces(tube_number)
    mask = (
        (df[TANK_COL] == safe_strip(tank_id).upper()) &
        (df[BOX_LABEL_COL] == safe_strip(box_label_group)) &
        (df[BOXID_COL] == safe_strip(boxid)) &
        (df[TUBE_COL] == tube_number_norm)
    )
    hits = df[mask]
    if hits.empty:
        return None, None
    idx0 = int(hits.index[0])
    cur_amount = to_int_amount(hits.iloc[0].get(AMT_COL, 0), default=0)
    return idx0, cur_amount

def get_ln_racknumber_by_index(ln_all_df: pd.DataFrame, idx0: int) -> str:
    try:
        if ln_all_df is None or ln_all_df.empty:
            return ""
        if RACK_COL not in ln_all_df.columns:
            return ""
        return safe_strip(ln_all_df.loc[idx0, RACK_COL])
    except Exception:
        return ""

def find_freezer_row_index(fr_all_df: pd.DataFrame, freezer_id: str, box_label_group: str, boxid: str, prefix: str, suffix: str):
    if fr_all_df is None or fr_all_df.empty:
        return None, None
    needed = {FREEZER_COL, BOX_LABEL_COL, BOXID_COL, PREFIX_COL, SUFFIX_COL, AMT_COL}
    if not needed.issubset(set(fr_all_df.columns)):
        return None, None

    df = fr_all_df.copy()
    df[FREEZER_COL] = df[FREEZER_COL].astype(str).map(lambda x: safe_strip(x).upper())
    df[BOX_LABEL_COL] = df[BOX_LABEL_COL].astype(str).map(safe_strip)
    df[BOXID_COL] = df[BOXID_COL].astype(str).map(safe_strip)
    df[PREFIX_COL] = df[PREFIX_COL].astype(str).map(lambda x: safe_strip(x).upper())
    df[SUFFIX_COL] = df[SUFFIX_COL].astype(str).map(normalize_spaces)

    suffix_norm = normalize_spaces(suffix)
    mask = (
        (df[FREEZER_COL] == safe_strip(freezer_id).upper()) &
        (df[BOX_LABEL_COL] == safe_strip(box_label_group)) &
        (df[BOXID_COL] == safe_strip(boxid)) &
        (df[PREFIX_COL] == safe_strip(prefix).upper()) &
        (df[SUFFIX_COL] == suffix_norm)
    )
    hits = df[mask]
    if hits.empty:
        return None, None
    idx0 = int(hits.index[0])
    cur_amount = to_int_amount(hits.iloc[0].get(AMT_COL, 0), default=0)
    return idx0, cur_amount

def show_df_view(df: pd.DataFrame, key_cols: list, height_mobile: int = 360, height_desktop: int = 520, key_prefix: str = "df"):
    if df is None or df.empty:
        st.info("No records.")
        return

    show_all = st.checkbox(
        "Show all columns",
        value=not st.session_state.mobile_mode,
        key=f"{key_prefix}_show_all",
    )

    if st.session_state.mobile_mode and not show_all:
        cols = [c for c in key_cols if c in df.columns]
        st.dataframe(df[cols] if cols else df, use_container_width=True, hide_index=True, height=height_mobile)
    else:
        st.dataframe(df, use_container_width=True, hide_index=True, height=height_desktop)

def build_box_map() -> dict:
    df = read_tab_cached(BOX_TAB)
    if df.empty:
        return {}
    study_candidates = ["StudyID", "Study ID", "Study Id", "ID"]
    box_candidates = ["BoxNumber", "Box Number", "Box", "Box#", "Box #"]
    study_col = next((c for c in study_candidates if c in df.columns), None)
    box_col = next((c for c in box_candidates if c in df.columns), None)
    if study_col is None or box_col is None:
        return {}
    m = {}
    for _, r in df.iterrows():
        sid = safe_strip(r.get(study_col, "")).upper()
        bx = safe_strip(r.get(box_col, ""))
        if sid:
            m[sid] = bx
    return m

# -------------------- Download filename helpers --------------------
def sanitize_filename_part(s: str, max_len: int = 40) -> str:
    s = safe_strip(s)
    if not s:
        return "NA"
    s = re.sub(r"\s+", "_", s.strip())
    s = re.sub(r"[^A-Za-z0-9_.-]+", "-", s)
    s = s.strip("._-")
    return s[:max_len] if len(s) > max_len else s

def timestamp_for_filename(ts: str) -> str:
    ts = safe_strip(ts)
    try:
        dt = datetime.strptime(ts, "%I:%M:%S %m/%d/%Y")
        return dt.strftime("%Y-%m-%d_%H-%M-%S")
    except Exception:
        return sanitize_filename_part(ts, max_len=30)

def build_report_filename(df: pd.DataFrame, prefix: str = "report", ext: str = "csv") -> str:
    if df is None or df.empty:
        return f"{prefix}_EMPTY.{ext}"

    tube_col = "TubeNumber" if "TubeNumber" in df.columns else None
    ship_col = "ShippingTo" if "ShippingTo" in df.columns else None
    ts_col = "Time_stamp" if "Time_stamp" in df.columns else None

    row = df.iloc[-1]
    tube = sanitize_filename_part(row.get(tube_col, "NA")) if tube_col else "NA"
    ship = sanitize_filename_part(row.get(ship_col, "NA")) if ship_col else "NA"
    ts = timestamp_for_filename(row.get(ts_col, "")) if ts_col else sanitize_filename_part(today_str_ny())
    return f"{prefix}_Tube-{tube}_Ship-{ship}_TS-{ts}.{ext}"

# ============================================================
# Preflight (NO DEBUG)
# ============================================================
service = sheets_service()

try:
    titles = get_sheet_titles(SPREADSHEET_ID)
except Exception:
    st.error("‚ùå Unable to connect to Google Sheets. Check credentials / sheet access.")
    st.stop()

required_tabs = [USE_LOG_TAB, LN_TAB, FREEZER_TAB, BOX_TAB]
study_required = list(TAB_MAP.values())
missing_tabs = [t for t in required_tabs if t not in titles]
missing_study = [t for t in study_required if t not in titles]

if missing_tabs or missing_study:
    st.error("‚ùå Google Sheet is missing required tabs.")
    if missing_tabs:
        st.caption(f"Missing required tabs: {missing_tabs}")
    if missing_study:
        st.caption(f"Missing study tabs: {missing_study}")
    st.stop()

try:
    _ = get_sheet_id_map(SPREADSHEET_ID)
    ensure_use_log_header(service)
    ensure_ln_header(service)
    ensure_freezer_header(service)
    ensure_boxnumber_header(service)
except Exception:
    st.error("‚ùå Sheet preflight failed (headers/tabs).")
    st.stop()

# ============================================================
# Header: title + status + context
# ============================================================
st.title("üì¶ Sample Inventory")

c_status, c_toggle = st.columns([1, 1])
with c_status:
    st.success("Connected", icon="‚úÖ")
with c_toggle:
    st.session_state.mobile_mode = st.toggle("üì± Mobile", value=st.session_state.mobile_mode)

# -------------------- Context Bar --------------------
ctx1, ctx2, ctx3 = st.columns([1.25, 1, 1])
with ctx1:
    selected_display_tab = st.selectbox("Study", DISPLAY_TABS, index=0, key="ctx_study")
with ctx2:
    STORAGE_TYPE = st.selectbox("Storage", ["LN Tank", "Freezer"], index=0, key="ctx_storage")
with ctx3:
    if STORAGE_TYPE == "LN Tank":
        selected_tank = st.selectbox("Tank", ["LN1", "LN2", "LN3"], index=2, key="ctx_tank")
        selected_freezer = None
    else:
        selected_freezer = st.selectbox("Freezer", ["Sammy", "Tom", "Jerry"], index=0, key="ctx_freezer")
        selected_tank = None

# ============================================================
# Top-level mode tabs
# ============================================================
tab_find, tab_add, tab_use, tab_history, tab_session = st.tabs(
    ["üîé Find", "‚ûï Add", "üìâ Use", "üßæ History", "‚úÖ Session Report"]
)

# ============================================================
# FIND
# ============================================================
with tab_find:
    st.subheader("Find / Locate")

    def should_focus_freezer_search() -> bool:
        return (STORAGE_TYPE == "Freezer") and (safe_strip(selected_freezer) in ["Tom", "Jerry"])

    def scroll_into_view(anchor_id: str):
        # Best-effort: no harm if blocked.
        components.html(
            f"""
            <script>
              const tryScroll = () => {{
                const el = window.parent.document.getElementById("{anchor_id}");
                if (el) el.scrollIntoView({{behavior: "smooth", block: "start"}});
              }};
              setTimeout(tryScroll, 50);
              setTimeout(tryScroll, 250);
              setTimeout(tryScroll, 600);
            </script>
            """,
            height=0,
        )

    focus_freezer_search = should_focus_freezer_search()

    def render_freezer_search():
        try:
            fr_all_df = read_tab_cached(FREEZER_TAB)
            if fr_all_df.empty:
                st.info("Freezer_Inventory is empty.")
                return
            if BOX_LABEL_COL not in fr_all_df.columns:
                st.error(f"Missing column '{BOX_LABEL_COL}' in {FREEZER_TAB}.")
                return

            df_search = fr_all_df.copy()
            if FREEZER_COL in df_search.columns:
                df_search[FREEZER_COL] = df_search[FREEZER_COL].astype(str).map(lambda x: safe_strip(x).upper())

            df_search = df_search[df_search[FREEZER_COL] == safe_strip(selected_freezer).upper()].copy()
            if df_search.empty:
                st.info(f"No records for {selected_freezer}.")
                return

            df_search[BOX_LABEL_COL] = df_search[BOX_LABEL_COL].astype(str).map(safe_strip)
            groups = sorted([g for g in df_search[BOX_LABEL_COL].dropna().unique().tolist() if safe_strip(g)])

            mode = st.radio("Mode", ["Exact", "Contains"], horizontal=not st.session_state.mobile_mode, key="find_fr_mode")

            if mode == "Exact":
                chosen_group = st.selectbox("BoxLabel_group", ["(select)"] + groups, key="find_fr_group_exact")
                if chosen_group != "(select)":
                    out = df_search[df_search[BOX_LABEL_COL] == safe_strip(chosen_group)].copy()
                    st.caption(f"Matches: {len(out)}")
                    show_df_view(
                        out,
                        key_cols=[FREEZER_COL, BOX_LABEL_COL, BOXID_COL, PREFIX_COL, SUFFIX_COL, AMT_COL, DATE_COLLECTED_COL, MEMO_COL],
                        height_mobile=320,
                        height_desktop=420,
                        key_prefix="find_fr_exact",
                    )
            else:
                q = st.text_input("BoxLabel_group contains‚Ä¶", placeholder="e.g., HP-COC", key="find_fr_contains").strip()
                if q:
                    out = df_search[df_search[BOX_LABEL_COL].astype(str).str.lower().str.contains(q.lower(), na=False)].copy()
                    st.caption(f"Matches: {len(out)}")
                    show_df_view(
                        out,
                        key_cols=[FREEZER_COL, BOX_LABEL_COL, BOXID_COL, PREFIX_COL, SUFFIX_COL, AMT_COL, DATE_COLLECTED_COL, MEMO_COL],
                        height_mobile=320,
                        height_desktop=420,
                        key_prefix="find_fr_contains_view",
                    )
                else:
                    st.info("Type a search term to filter.")
        except Exception:
            st.error("Freezer search failed.")

    # --- FREEZER MODE: Focus Freezer Search FIRST (Tom/Jerry), then Box Location always visible ---
    if STORAGE_TYPE == "Freezer":
        # Anchor to scroll to the focused section
        st.markdown("<div id='freezer_search_anchor'></div>", unsafe_allow_html=True)

        if focus_freezer_search:
            st.markdown("<div class='focus-card'>", unsafe_allow_html=True)
            st.markdown("### üßä Freezer Search by BoxLabel_group")
            st.caption("Focused view (Tom/Jerry) ‚Äî this section stays on top.")
            render_freezer_search()
            st.markdown("</div>", unsafe_allow_html=True)
            scroll_into_view("freezer_search_anchor")
        else:
            with st.expander("üßä Freezer Search by BoxLabel_group", expanded=True):
                render_freezer_search()

        # Box Location always visible (cannot be minimized)
        boxloc_title = f"üì¶ {safe_strip(selected_freezer).upper()}: Box Location"
        st.markdown(f"<div class='boxloc-card'><h3>{boxloc_title}</h3></div>", unsafe_allow_html=True)

        tab_name = TAB_MAP[selected_display_tab]
        try:
            df = read_tab_cached(tab_name)
            if df.empty:
                st.info(f"No data found in tab: {tab_name}")
            else:
                show_df_view(
                    df,
                    key_cols=["StudyID", "Visit", "SampleID", "Memo"],
                    height_mobile=360,
                    height_desktop=520,
                    key_prefix="find_boxloc",
                )

                st.markdown("**StudyID ‚Üí BoxNumber**")
                if "StudyID" not in df.columns:
                    st.info("This tab does not have a 'StudyID' column.")
                else:
                    studyids = df["StudyID"].dropna().astype(str).map(safe_strip)
                    options = sorted([s for s in studyids.unique().tolist() if s])
                    selected_studyid = st.selectbox("StudyID", ["(select)"] + options, key="find_studyid")
                    if selected_studyid != "(select)":
                        box_map = build_box_map()
                        box = box_map.get(safe_strip(selected_studyid).upper(), "")
                        if safe_strip(box) == "":
                            st.error("BoxNumber: Not Found")
                        else:
                            st.success(f"BoxNumber: {box}")
        except Exception:
            st.error("Box Location failed.")

    # --- LN MODE: Box Location collapsed by default, then LN table ---
    else:
        boxloc_title = "üì¶ Box Location"
        with st.expander(boxloc_title, expanded=False):
            tab_name = TAB_MAP[selected_display_tab]
            try:
                df = read_tab_cached(tab_name)
                if df.empty:
                    st.info(f"No data found in tab: {tab_name}")
                else:
                    show_df_view(
                        df,
                        key_cols=["StudyID", "Visit", "SampleID", "Memo"],
                        height_mobile=360,
                        height_desktop=520,
                        key_prefix="find_boxloc",
                    )

                    st.markdown("**StudyID ‚Üí BoxNumber**")
                    if "StudyID" not in df.columns:
                        st.info("This tab does not have a 'StudyID' column.")
                    else:
                        studyids = df["StudyID"].dropna().astype(str).map(safe_strip)
                        options = sorted([s for s in studyids.unique().tolist() if s])
                        selected_studyid = st.selectbox("StudyID", ["(select)"] + options, key="find_studyid")
                        if selected_studyid != "(select)":
                            box_map = build_box_map()
                            box = box_map.get(safe_strip(selected_studyid).upper(), "")
                            if safe_strip(box) == "":
                                st.error("BoxNumber: Not Found")
                            else:
                                st.success(f"BoxNumber: {box}")
            except Exception:
                st.error("Box Location failed.")

        with st.expander(f"üßä LN Inventory Table ({selected_tank})", expanded=True):
            try:
                ln_all_df = read_tab_cached(LN_TAB)
                if ln_all_df.empty:
                    st.info("LN3 is empty.")
                else:
                    try:
                        deleted_idxs = cleanup_zero_amount_rows(service, LN_TAB, ln_all_df, AMT_COL)
                        if deleted_idxs:
                            read_tab_cached.clear()
                            ln_all_df = read_tab_cached(LN_TAB)
                    except Exception:
                        pass

                    if TANK_COL not in ln_all_df.columns:
                        st.error(f"LN3 missing required column: '{TANK_COL}'")
                    else:
                        ln_view_df = ln_all_df.copy()
                        ln_view_df[TANK_COL] = ln_view_df[TANK_COL].astype(str).map(lambda x: safe_strip(x).upper())
                        ln_view_df = ln_view_df[ln_view_df[TANK_COL] == safe_strip(selected_tank).upper()].copy()

                        if ln_view_df.empty:
                            st.info(f"No records for {selected_tank}.")
                        else:
                            show_df_view(
                                ln_view_df,
                                key_cols=[TANK_COL, RACK_COL, BOX_LABEL_COL, BOXID_COL, TUBE_COL, AMT_COL, MEMO_COL],
                                height_mobile=360,
                                height_desktop=520,
                                key_prefix="find_ln_table",
                            )
            except Exception:
                st.error("Failed to load LN inventory.")

# ============================================================
# ADD
# ============================================================
with tab_add:
    st.subheader("Add Inventory")

    # ---- LN only when Storage=LN Tank ----
    if STORAGE_TYPE == "LN Tank":
        st.subheader("üßä Add to LN")
        st.caption("LN Tank mode ‚Üí Add to LN only (Add to Freezer hidden).")

        selected_tank_add = st.selectbox("Tank", ["LN1", "LN2", "LN3"], index=2, key="add_ln_tank")

        try:
            ln_all_df = read_tab_cached(LN_TAB)
        except Exception:
            ln_all_df = pd.DataFrame()

        ln_view_df = ln_all_df.copy()
        if not ln_view_df.empty and TANK_COL in ln_view_df.columns:
            ln_view_df[TANK_COL] = ln_view_df[TANK_COL].astype(str).map(lambda x: safe_strip(x).upper())
            ln_view_df = ln_view_df[ln_view_df[TANK_COL] == safe_strip(selected_tank_add).upper()].copy()

        with st.form("add_ln_form", clear_on_submit=True):
            rack = st.selectbox("RackNumber", [1, 2, 3, 4, 5, 6], index=0, key="add_ln_rack")
            hiv_status = st.selectbox("HIV Status", ["HIV+", "HIV-"], index=0, key="add_ln_hiv")
            drug_group = st.selectbox("Drug Group", ["Cocaine", "Cannabis", "Poly", "NON-DRUG"], index=0, key="add_ln_drug")

            hp_hn = HIV_CODE[hiv_status]
            drug_code = DRUG_CODE.get(drug_group)
            if not drug_code:
                st.error(f"Unknown Drug Group: {drug_group}. Please update DRUG_CODE.")
                st.stop()

            box_label_group = f"{hp_hn}-{drug_code}"

            # ‚úÖ LN max from LN3
            current_max_boxid = get_current_max_boxid_from_ln3()

            box_options = ["Open new box"] if current_max_boxid == 0 else ["Use previous box", "Open new box"]
            box_choice = st.radio(
                "BoxID option",
                box_options,
                horizontal=not st.session_state.mobile_mode,
                key="add_ln_box_choice",
            )
            opened_new_box = (box_choice == "Open new box")
            boxid_val = (max(current_max_boxid, 0) + 1) if opened_new_box else max(current_max_boxid, 1)

            st.text_input("BoxID (locked)", value=str(int(boxid_val)), disabled=True, key="add_ln_boxid_locked")
            boxid_input = str(int(boxid_val))

            tube_prefix = st.selectbox("Tube Prefix", ["GICU", "HCCU"], index=0, key="add_ln_prefix")
            tube_suffix = st.text_input("Tube suffix", placeholder="e.g., 02 036", key="add_ln_suffix").strip()
            tube_amount = st.number_input("TubeAmount", min_value=1, step=1, value=1, key="add_ln_amt")
            memo = st.text_area("Memo (optional)", key="add_ln_memo")

            tube_number = normalize_spaces(f"{tube_prefix} {tube_suffix}" if tube_suffix else "")

            preview_uid, preview_qr, preview_err = "", "", ""
            try:
                preview_uid = compute_next_boxuid(ln_view_df, selected_tank_add, rack, hp_hn, drug_code)
                preview_qr = qr_link_for_boxuid(preview_uid)
            except Exception as e:
                preview_err = str(e)

            if preview_err:
                st.error(preview_err)
            else:
                st.info(f"BoxUID (auto): {preview_uid}")
                st.image(preview_qr, width=QR_PX)

            submitted = st.form_submit_button("Save to LN3", type="primary")
            if submitted:
                if not tube_suffix:
                    st.error("Tube suffix is required.")
                    st.stop()

                try:
                    box_uid = compute_next_boxuid(ln_view_df, selected_tank_add, rack, hp_hn, drug_code)
                    qr_link = qr_link_for_boxuid(box_uid)

                    data = {
                        TANK_COL: safe_strip(selected_tank_add).upper(),
                        RACK_COL: int(rack),
                        BOX_LABEL_COL: box_label_group,
                        BOXUID_COL: box_uid,
                        TUBE_COL: tube_number,
                        AMT_COL: int(tube_amount),
                        MEMO_COL: memo,
                        BOXID_COL: boxid_input,
                        QR_COL: qr_link,
                    }
                    append_row_by_header(service, LN_TAB, data)
                    read_tab_cached.clear()
                    st.success(f"Saved ‚úÖ {box_uid}")

                    if opened_new_box:
                        st.warning(f"New box opened ‚Üí mark BoxID = {boxid_input}")

                    st.session_state.last_qr_link = qr_link
                    st.session_state.last_qr_uid = box_uid
                    st.rerun()
                except Exception:
                    st.error("Failed to save LN record")

        if st.session_state.last_qr_link:
            try:
                png_bytes = fetch_bytes(st.session_state.last_qr_link)
                st.download_button(
                    label="‚¨áÔ∏è Download last saved QR PNG",
                    data=png_bytes,
                    file_name=f"{st.session_state.last_qr_uid or 'LN'}.png",
                    mime="image/png",
                    key="download_last_qr_png",
                )
            except Exception:
                st.warning("Saved, but QR download failed.")

    # ---- Freezer only when Storage=Freezer ----
    else:
        st.subheader("üßä Add to Freezer")
        st.caption("Freezer mode ‚Üí Add to Freezer only (Add to LN hidden).")

        default_date = today_str_ny()

        # ‚úÖ Freezer max from boxNumber
        current_max_boxnumber = get_current_max_boxid_from_boxnumber()
        st.caption(f"Current max BoxNumber (from boxNumber tab): {current_max_boxnumber if current_max_boxnumber else '(none)'}")

        freezer_id_default = safe_strip(selected_freezer).upper()

        with st.form("add_fr_form", clear_on_submit=True):
            st.text_input("FreezerID (from context)", value=freezer_id_default, disabled=True, key="add_fr_freezer_locked")
            freezer_id = freezer_id_default

            box_choice = st.radio(
                "BoxID option",
                ["Use previous box", "Open new box"],
                horizontal=not st.session_state.mobile_mode,
                key="add_fr_box_choice",
            )
            boxid_val = max(current_max_boxnumber, 1) if box_choice == "Use previous box" else (max(current_max_boxnumber, 0) + 1)
            st.text_input("BoxID (locked)", value=str(int(boxid_val)), disabled=True, key="add_fr_boxid_locked")
            boxid = str(int(boxid_val))

            box_label_group = st.text_input("BoxLabel_group", placeholder="e.g., HP-COC / HN-CAN", key="add_fr_group").strip()
            prefix = st.text_input("Prefix", placeholder="e.g., AD / GICU / HCCU", key="add_fr_prefix").strip().upper()
            tube_suffix = st.text_input("Tube suffix", placeholder="e.g., 99 999", key="add_fr_suffix").strip()
            tube_amount = st.number_input("TubeAmount", min_value=1, step=1, value=1, key="add_fr_amt")

            date_collected = st.text_input("Date Collected", value=default_date, key="add_fr_date").strip()
            samples_received = st.text_input("Samples Received (optional)", key="add_fr_samples").strip()
            missing = st.text_input("Missing (optional)", key="add_fr_missing").strip()
            urine_results = st.text_input("Urine Results (optional)", key="add_fr_urine").strip()
            collected_by = st.text_input("Collected By (optional)", key="add_fr_by").strip()
            memo = st.text_area("Memo (optional)", key="add_fr_memo").strip()

            submitted = st.form_submit_button("Save to Freezer_Inventory", type="primary")
            if submitted:
                if not box_label_group:
                    st.error("BoxLabel_group is required."); st.stop()
                if not prefix:
                    st.error("Prefix is required."); st.stop()
                if not tube_suffix:
                    st.error("Tube suffix is required."); st.stop()

                try:
                    fr_all_df = read_tab_cached(FREEZER_TAB)
                except Exception:
                    fr_all_df = pd.DataFrame()

                def _norm(s: str) -> str:
                    return normalize_spaces(s)

                key_freezer = _norm(freezer_id).upper()
                key_group = _norm(box_label_group)
                key_boxid = _norm(boxid)
                key_prefix = _norm(prefix).upper()
                key_suffix = _norm(tube_suffix)

                if not fr_all_df.empty:
                    needed = {FREEZER_COL, BOX_LABEL_COL, BOXID_COL, PREFIX_COL, SUFFIX_COL}
                    if needed.issubset(set(fr_all_df.columns)):
                        dfchk = fr_all_df.copy()
                        dfchk[FREEZER_COL] = dfchk[FREEZER_COL].astype(str).map(lambda x: _norm(x).upper())
                        dfchk[BOX_LABEL_COL] = dfchk[BOX_LABEL_COL].astype(str).map(_norm)
                        dfchk[BOXID_COL] = dfchk[BOXID_COL].astype(str).map(_norm)
                        dfchk[PREFIX_COL] = dfchk[PREFIX_COL].astype(str).map(lambda x: _norm(x).upper())
                        dfchk[SUFFIX_COL] = dfchk[SUFFIX_COL].astype(str).map(_norm)

                        dup_mask = (
                            (dfchk[FREEZER_COL] == key_freezer) &
                            (dfchk[BOX_LABEL_COL] == key_group) &
                            (dfchk[BOXID_COL] == key_boxid) &
                            (dfchk[PREFIX_COL] == key_prefix) &
                            (dfchk[SUFFIX_COL] == key_suffix)
                        )
                        if dup_mask.any():
                            hit = dfchk.loc[dup_mask].head(1)
                            existing_amt = hit.iloc[0].get(AMT_COL, "")
                            st.error(f"Duplicate exists. Existing TubeAmount={existing_amt}.")
                            st.stop()

                data = {
                    FREEZER_COL: freezer_id,
                    BOXID_COL: boxid,
                    PREFIX_COL: prefix,
                    SUFFIX_COL: normalize_spaces(tube_suffix),
                    AMT_COL: int(tube_amount),
                    DATE_COLLECTED_COL: date_collected,
                    BOX_LABEL_COL: box_label_group,
                    SAMPLES_RECEIVED_COL: samples_received,
                    MISSING_COL: missing,
                    URINE_RESULTS_COL: urine_results,
                    COLLECTED_BY_COL: collected_by,
                    MEMO_COL: memo,
                }

                try:
                    append_row_by_header(service, FREEZER_TAB, data)

                    # After saving Freezer record -> insert NEW row into boxNumber
                    study_id_value = normalize_spaces(f"{prefix} {tube_suffix}".strip())
                    try:
                        insert_boxnumber_row(service, study_id_value, boxid)
                    except Exception:
                        st.warning("Saved freezer record, but boxNumber insert failed.")

                    read_tab_cached.clear()
                    st.success("Saved ‚úÖ Freezer_Inventory record")
                    st.rerun()
                except Exception:
                    st.error("Failed to save Freezer_Inventory record")

# ============================================================
# USE
# ============================================================
with tab_use:
    st.subheader("Use / Log Usage")
    st.caption("Select an item ‚Üí enter Use + User + ShippingTo ‚Üí submits to Use_log and subtracts TubeAmount.")

    ln_all_df = read_tab_cached(LN_TAB)
    fr_all_df = read_tab_cached(FREEZER_TAB)

    try:
        if not ln_all_df.empty:
            deleted_ln = cleanup_zero_amount_rows(service, LN_TAB, ln_all_df, AMT_COL)
            if deleted_ln:
                read_tab_cached.clear()
                ln_all_df = read_tab_cached(LN_TAB)
    except Exception:
        pass

    try:
        if not fr_all_df.empty and (AMT_COL in fr_all_df.columns):
            fr_amt = pd.to_numeric(fr_all_df[AMT_COL], errors="coerce").fillna(0).astype(int)
            zero_idxs = [int(i) for i in fr_all_df.index[fr_amt == 0].tolist()]

            study_ids_to_delete = []
            for idx0 in zero_idxs:
                sid = freezer_studyid_from_row(fr_all_df, idx0)
                if sid:
                    study_ids_to_delete.append(sid)

            deleted_fr = cleanup_zero_amount_rows(service, FREEZER_TAB, fr_all_df, AMT_COL)
            if deleted_fr:
                for sid in study_ids_to_delete:
                    try:
                        delete_boxnumber_rows_by_studyid(service, sid)
                    except Exception:
                        pass

                read_tab_cached.clear()
                fr_all_df = read_tab_cached(FREEZER_TAB)
    except Exception:
        pass

    if STORAGE_TYPE == "LN Tank":
        if ln_all_df.empty:
            st.info("LN3 is empty.")
        else:
            dfv = ln_all_df.copy()
            needed = {TANK_COL, RACK_COL, BOX_LABEL_COL, BOXID_COL, TUBE_COL, AMT_COL}
            if not needed.issubset(set(dfv.columns)):
                st.error(f"LN3 missing required columns: {', '.join(sorted(list(needed)))}")
            else:
                dfv[TANK_COL] = dfv[TANK_COL].astype(str).map(lambda x: safe_strip(x).upper())
                dfv[RACK_COL] = dfv[RACK_COL].astype(str).map(safe_strip)
                dfv[BOX_LABEL_COL] = dfv[BOX_LABEL_COL].astype(str).map(safe_strip)
                dfv[BOXID_COL] = dfv[BOXID_COL].astype(str).map(safe_strip)
                dfv[TUBE_COL] = dfv[TUBE_COL].astype(str).map(normalize_spaces)
                dfv[AMT_COL] = pd.to_numeric(dfv[AMT_COL], errors="coerce").fillna(0).astype(int)

                dfv["_prefix"] = dfv[TUBE_COL].map(lambda x: split_tube_number(x)[0].upper())
                dfv["_suffix"] = dfv[TUBE_COL].map(lambda x: split_tube_number(x)[1])

                scoped = dfv[dfv[TANK_COL] == safe_strip(selected_tank).upper()].copy()
                if scoped.empty:
                    st.info(f"No records for {selected_tank}.")
                else:
                    c1, c2, c3 = st.columns([1, 1, 1])
                    with c1:
                        chosen_box = st.selectbox(
                            "BoxLabel_group",
                            ["(select)"] + sorted([b for b in scoped[BOX_LABEL_COL].dropna().unique().tolist() if safe_strip(b)]),
                            key="use_ln_box",
                        )
                    scoped2 = scoped[scoped[BOX_LABEL_COL] == safe_strip(chosen_box)].copy() if chosen_box != "(select)" else scoped.iloc[0:0].copy()

                    with c2:
                        chosen_boxid = st.selectbox(
                            "BoxID",
                            ["(select)"] + sorted([x for x in scoped2[BOXID_COL].dropna().unique().tolist() if safe_strip(x)]),
                            key="use_ln_boxid",
                        )
                    scoped3 = scoped2[scoped2[BOXID_COL] == safe_strip(chosen_boxid)].copy() if chosen_boxid != "(select)" else scoped2.iloc[0:0].copy()

                    with c3:
                        chosen_prefix = st.selectbox(
                            "Prefix",
                            ["(select)"] + sorted([p for p in scoped3["_prefix"].dropna().unique().tolist() if safe_strip(p)]),
                            key="use_ln_prefix",
                        )
                    scoped4 = scoped3[scoped3["_prefix"] == safe_strip(chosen_prefix).upper()].copy() if chosen_prefix != "(select)" else scoped3.iloc[0:0].copy()

                    chosen_suffix = st.selectbox(
                        "Tube suffix",
                        ["(select)"] + sorted([s for s in scoped4["_suffix"].dropna().unique().tolist() if safe_strip(s)]),
                        key="use_ln_suffix",
                    )

                    match_df = scoped4[scoped4["_suffix"] == safe_strip(chosen_suffix)].copy() if chosen_suffix != "(select)" else scoped4.iloc[0:0].copy()

                    if not match_df.empty:
                        r = match_df.iloc[0]
                        st.info(
                            f"Match: Tank {r.get(TANK_COL,'')} | Rack {r.get(RACK_COL,'')} | "
                            f"Box {r.get(BOX_LABEL_COL,'')} | BoxID {r.get(BOXID_COL,'')} | "
                            f"TubeAmount {r.get(AMT_COL,'')}"
                        )
                        show_cols = [TANK_COL, RACK_COL, BOX_LABEL_COL, BOXID_COL, TUBE_COL, AMT_COL, MEMO_COL]
                        show_cols = [c for c in show_cols if c in match_df.columns]
                        st.dataframe(match_df[show_cols], use_container_width=True, hide_index=True, height=200)

                    with st.form("use_ln_submit"):
                        use_amt = st.number_input("Use", min_value=1, step=1, value=1, key="use_ln_amt")
                        user_initials = st.text_input("User initials", placeholder="e.g., JW", key="use_ln_user").strip()
                        shipping_to = st.text_input("ShippingTo", placeholder="e.g., Dr. Smith / UCSF", key="use_ln_ship").strip()
                        memo_in = st.text_area("Memo (optional)", key="use_ln_memo").strip()

                        submitted_use = st.form_submit_button("Submit Usage (LN)", type="primary")
                        if submitted_use:
                            if "(select)" in [chosen_box, chosen_boxid, chosen_prefix, chosen_suffix]:
                                st.error("Please select BoxLabel_group, BoxID, Prefix, and Tube suffix.")
                                st.stop()
                            if not user_initials:
                                st.error("User initials required.")
                                st.stop()
                            if not shipping_to:
                                st.error("ShippingTo required.")
                                st.stop()

                            tube_number = normalize_spaces(f"{safe_strip(chosen_prefix).upper()} {safe_strip(chosen_suffix)}".strip())
                            idx0, cur_amount = find_ln_row_index(ln_all_df, selected_tank, chosen_box, chosen_boxid, tube_number)
                            if idx0 is None:
                                st.error("No matching LN3 row found.")
                                st.stop()

                            new_amount = int(cur_amount) - int(use_amt)
                            if new_amount < 0:
                                st.error(f"Not enough stock. Current={cur_amount}, Use={int(use_amt)}")
                                st.stop()

                            rack_number = get_ln_racknumber_by_index(ln_all_df, idx0)

                            append_row_by_header(
                                service,
                                USE_LOG_TAB,
                                build_use_log_row(
                                    storage_type="LN",
                                    tank_id=selected_tank,
                                    rack_number=rack_number,
                                    freezer_id="",
                                    box_label_group=chosen_box,
                                    boxid=chosen_boxid,
                                    prefix=chosen_prefix,
                                    suffix=chosen_suffix,
                                    use_amt=int(use_amt),
                                    user_initials=user_initials,
                                    shipping_to=shipping_to,
                                    memo_in=memo_in,
                                ),
                            )

                            if new_amount == 0:
                                delete_row_by_index(service, LN_TAB, idx0)
                                st.success("Logged ‚úÖ Saved to Use_log. TubeAmount reached 0 ‚Üí row deleted.")
                            else:
                                update_amount_by_index(service, LN_TAB, idx0, AMT_COL, new_amount)
                                st.success(f"Logged ‚úÖ Remaining TubeAmount: {new_amount}")

                            ts = now_timestamp_str()
                            st.session_state.usage_final_rows.append(
                                build_final_report_row(
                                    storage_type="LN",
                                    storage_id=selected_tank,
                                    box_label_group=chosen_box,
                                    boxid=chosen_boxid,
                                    prefix=chosen_prefix,
                                    suffix=chosen_suffix,
                                    use_amt=int(use_amt),
                                    user_initials=user_initials,
                                    time_stamp=ts,
                                    shipping_to=shipping_to,
                                    memo=memo_in,
                                )
                            )
                            read_tab_cached.clear()
                            st.rerun()

    else:
        if fr_all_df.empty:
            st.info("Freezer_Inventory is empty.")
        else:
            dfv = fr_all_df.copy()
            needed = {FREEZER_COL, BOX_LABEL_COL, BOXID_COL, PREFIX_COL, SUFFIX_COL, AMT_COL}
            if not needed.issubset(set(dfv.columns)):
                st.error(f"{FREEZER_TAB} missing required columns: {', '.join(sorted(list(needed)))}")
            else:
                dfv[FREEZER_COL] = dfv[FREEZER_COL].astype(str).map(lambda x: safe_strip(x).upper())
                dfv[BOX_LABEL_COL] = dfv[BOX_LABEL_COL].astype(str).map(safe_strip)
                dfv[BOXID_COL] = dfv[BOXID_COL].astype(str).map(safe_strip)
                dfv[PREFIX_COL] = dfv[PREFIX_COL].astype(str).map(lambda x: safe_strip(x).upper())
                dfv[SUFFIX_COL] = dfv[SUFFIX_COL].astype(str).map(normalize_spaces)
                dfv[AMT_COL] = pd.to_numeric(dfv[AMT_COL], errors="coerce").fillna(0).astype(int)

                scoped = dfv[dfv[FREEZER_COL] == safe_strip(selected_freezer).upper()].copy()
                if scoped.empty:
                    st.info(f"No records for {selected_freezer}.")
                else:
                    c1, c2, c3 = st.columns([1, 1, 1])
                    with c1:
                        chosen_box = st.selectbox(
                            "BoxLabel_group",
                            ["(select)"] + sorted([b for b in scoped[BOX_LABEL_COL].dropna().unique().tolist() if safe_strip(b)]),
                            key="use_fr_box",
                        )
                    scoped2 = scoped[scoped[BOX_LABEL_COL] == safe_strip(chosen_box)].copy() if chosen_box != "(select)" else scoped.iloc[0:0].copy()

                    with c2:
                        chosen_boxid = st.selectbox(
                            "BoxID",
                            ["(select)"] + sorted([x for x in scoped2[BOXID_COL].dropna().unique().tolist() if safe_strip(x)]),
                            key="use_fr_boxid",
                        )
                    scoped3 = scoped2[scoped2[BOXID_COL] == safe_strip(chosen_boxid)].copy() if chosen_boxid != "(select)" else scoped2.iloc[0:0].copy()

                    with c3:
                        chosen_prefix = st.selectbox(
                            "Prefix",
                            ["(select)"] + sorted([p for p in scoped3[PREFIX_COL].dropna().unique().tolist() if safe_strip(p)]),
                            key="use_fr_prefix",
                        )
                    scoped4 = scoped3[scoped3[PREFIX_COL] == safe_strip(chosen_prefix).upper()].copy() if chosen_prefix != "(select)" else scoped3.iloc[0:0].copy()

                    chosen_suffix = st.selectbox(
                        "Tube suffix",
                        ["(select)"] + sorted([s for s in scoped4[SUFFIX_COL].dropna().unique().tolist() if safe_strip(s)]),
                        key="use_fr_suffix",
                    )

                    match_df = scoped4[scoped4[SUFFIX_COL] == safe_strip(chosen_suffix)].copy() if chosen_suffix != "(select)" else scoped4.iloc[0:0].copy()

                    if not match_df.empty:
                        r = match_df.iloc[0]
                        st.info(
                            f"Match: Freezer {r.get(FREEZER_COL,'')} | Box {r.get(BOX_LABEL_COL,'')} | "
                            f"BoxID {r.get(BOXID_COL,'')} | TubeAmount {r.get(AMT_COL,'')}"
                        )
                        show_cols = [FREEZER_COL, BOX_LABEL_COL, BOXID_COL, PREFIX_COL, SUFFIX_COL, AMT_COL, DATE_COLLECTED_COL, MEMO_COL]
                        show_cols = [c for c in show_cols if c in match_df.columns]
                        st.dataframe(match_df[show_cols], use_container_width=True, hide_index=True, height=200)

                    with st.form("use_fr_submit"):
                        use_amt = st.number_input("Use", min_value=1, step=1, value=1, key="use_fr_amt")
                        user_initials = st.text_input("User initials", placeholder="e.g., JW", key="use_fr_user").strip()
                        shipping_to = st.text_input("ShippingTo", placeholder="e.g., Dr. Smith / UCSF", key="use_fr_ship").strip()
                        memo_in = st.text_area("Memo (optional)", key="use_fr_memo").strip()

                        submitted_use = st.form_submit_button("Submit Usage (Freezer)", type="primary")
                        if submitted_use:
                            if "(select)" in [chosen_box, chosen_boxid, chosen_prefix, chosen_suffix]:
                                st.error("Please select BoxLabel_group, BoxID, Prefix, and Tube suffix.")
                                st.stop()
                            if not user_initials:
                                st.error("User initials required.")
                                st.stop()
                            if not shipping_to:
                                st.error("ShippingTo required.")
                                st.stop()

                            idx0, cur_amount = find_freezer_row_index(
                                fr_all_df,
                                freezer_id=selected_freezer,
                                box_label_group=chosen_box,
                                boxid=chosen_boxid,
                                prefix=chosen_prefix,
                                suffix=chosen_suffix,
                            )
                            if idx0 is None:
                                st.error("No matching Freezer_Inventory row found.")
                                st.stop()

                            new_amount = int(cur_amount) - int(use_amt)
                            if new_amount < 0:
                                st.error(f"Not enough stock. Current={cur_amount}, Use={int(use_amt)}")
                                st.stop()

                            append_row_by_header(
                                service,
                                USE_LOG_TAB,
                                build_use_log_row(
                                    storage_type="Freezer",
                                    tank_id="",
                                    rack_number="",
                                    freezer_id=selected_freezer,
                                    box_label_group=chosen_box,
                                    boxid=chosen_boxid,
                                    prefix=chosen_prefix,
                                    suffix=chosen_suffix,
                                    use_amt=int(use_amt),
                                    user_initials=user_initials,
                                    shipping_to=shipping_to,
                                    memo_in=memo_in,
                                ),
                            )

                            if new_amount == 0:
                                study_id_value = freezer_studyid_from_row(fr_all_df, idx0)
                                delete_row_by_index(service, FREEZER_TAB, idx0)
                                if study_id_value:
                                    try:
                                        delete_boxnumber_rows_by_studyid(service, study_id_value)
                                    except Exception:
                                        pass
                                st.success("Logged ‚úÖ Saved to Use_log. TubeAmount reached 0 ‚Üí row deleted.")
                            else:
                                update_amount_by_index(service, FREEZER_TAB, idx0, AMT_COL, new_amount)
                                st.success(f"Logged ‚úÖ Remaining TubeAmount: {new_amount}")

                            ts = now_timestamp_str()
                            st.session_state.usage_final_rows.append(
                                build_final_report_row(
                                    storage_type="Freezer",
                                    storage_id=selected_freezer,
                                    box_label_group=chosen_box,
                                    boxid=chosen_boxid,
                                    prefix=chosen_prefix,
                                    suffix=chosen_suffix,
                                    use_amt=int(use_amt),
                                    user_initials=user_initials,
                                    time_stamp=ts,
                                    shipping_to=shipping_to,
                                    memo=memo_in,
                                )
                            )
                            read_tab_cached.clear()
                            st.rerun()

# ============================================================
# HISTORY
# ============================================================
with tab_history:
    st.subheader("Use_log History")
    st.caption("View recent usage records (cached reads to reduce quota errors).")

    try:
        use_log_df = read_tab_cached(USE_LOG_TAB)
        if use_log_df.empty:
            st.info("Use_log is empty.")
        else:
            n = st.slider("Rows to show", 50, 2000, 200, step=50, key="hist_rows")
            tail_df = use_log_df.tail(n)

            key_cols = [
                "Time_stamp", "StorageType", "TankID", "RackNumber", "FreezerID",
                "BoxLabel_group", "BoxID", "TubeNumber", "Use", "User", "ShippingTo", "Memo",
            ]
            show_df_view(tail_df, key_cols=key_cols, height_mobile=360, height_desktop=520, key_prefix="hist_uselog")

            csv_bytes = tail_df.to_csv(index=False).encode("utf-8")
            fname = build_report_filename(tail_df, prefix="UseLog", ext="csv")
            st.download_button(
                "‚¨áÔ∏è Download displayed Use_log (CSV)",
                data=csv_bytes,
                file_name=fname,
                mime="text/csv",
                key="download_use_log_csv",
            )

    except Exception:
        st.error("Unable to read Use_log.")

# ============================================================
# SESSION REPORT
# ============================================================
with tab_session:
    st.subheader("Session Report")
    st.caption("This report includes only usage you logged during the current session (browser session).")

    final_cols = [
        "StorageType", "StorageID", "BoxLabel_group", "BoxID",
        "Prefix", "Tube suffix", "Use", "User", "Time_stamp",
        "ShippingTo", "Memo",
    ]

    if st.session_state.usage_final_rows:
        final_df = pd.DataFrame(st.session_state.usage_final_rows).reindex(columns=final_cols, fill_value="")
        show_df_view(final_df, key_cols=final_cols, height_mobile=360, height_desktop=520, key_prefix="session_final")

        csv_bytes = final_df.to_csv(index=False).encode("utf-8")

        name_df = final_df.copy()
        if "TubeNumber" not in name_df.columns and ("Prefix" in name_df.columns) and ("Tube suffix" in name_df.columns):
            name_df["TubeNumber"] = name_df.apply(
                lambda r: normalize_spaces(f"{safe_strip(r.get('Prefix',''))} {safe_strip(r.get('Tube suffix',''))}".strip()),
                axis=1,
            )

        fname = build_report_filename(name_df, prefix="SessionReport", ext="csv")

        st.download_button(
            "‚¨áÔ∏è Download session report (CSV)",
            data=csv_bytes,
            file_name=fname,
            mime="text/csv",
            key="download_session_report",
        )

        if st.button("üßπ Clear session report", key="clear_session_report"):
            st.session_state.usage_final_rows = []
            st.success("Session report cleared (Use_log remains saved).")
            st.rerun()
    else:
        st.info("No usage logged in this session yet.")
